[
  {
    "objectID": "01-BasicExample/quarto/main.html",
    "href": "01-BasicExample/quarto/main.html",
    "title": "Example 1",
    "section": "",
    "text": "Nous souhaitons dessiner l’image suivante en utilisant le package tikz :\n\nOn commence par créer un fichier standalone avec le contenu suivant :\n\\documentclass{standalone}\n\\begin{document}\n...\n\\end{document}\nA l’intérieur du document, on charge le package tikz et on crée une figure en utilisant l’environnement tikzpicture :\n\\documentclass{standalone}\n\n% Chargement du package tikz\n\\usepackage{tikz}\n\n\\begin{document}\n\\begin{tikzpicture}\n% Dessin ici\n\\end{tikzpicture}\n\\end{document}\n\n1 Version simple\nOn commence par dessiner un axe horizontal avec une flèche à son extrémité droite :\n\\draw[-&gt;, thick] (-0.5,0) -- (10.5,0);\nCette commande dessine une ligne épaisse avec une flèche allant du point (-0.5,0) au point (10.5,0). Le choix des coordonnées permet de laisser un peu d’espace avant le début de l’axe et après la fin de l’axe. La flèche est placée en utilisant l’option -&gt;. L’option thick rend la ligne plus épaisse. Le résultat est le suivant :\n\n\n\n\n\n\n\n\n\nEnsuite on peut ajouter des étiquettes sur l’axe en utilisant des segments verticaux et des nœuds pour les numéros. Par exemple, pour ajouter une étiquette sur le point 0, on peut utiliser la commande suivante :\n\\draw[-] (0, 0.2) -- (0, -0.2) node[below] {0};\nLa commande \\draw[-] dessine une ligne allant du point (0, 0.2) au point (0, -0.2). L’option node[below] {0} ajoute un nœud contenant le texte 0 en dessous de la ligne. Le résultat est le suivant :\n\n\n\n\n\n\n\n\n\nOn peut répéter cette commande pour ajouter des étiquettes de 0 à 10 sur l’axe :\n\\draw[-] (0, 0.2) -- (0, -0.2) node[below] {0};\n\\draw[-] (1, 0.2) -- (1, -0.2) node[below] {1};\n\\draw[-] (2, 0.2) -- (2, -0.2) node[below] {2};\n\\draw[-] (3, 0.2) -- (3, -0.2) node[below] {3};\n\\draw[-] (4, 0.2) -- (4, -0.2) node[below] {4};\n\\draw[-] (5, 0.2) -- (5, -0.2) node[below] {5};\n\\draw[-] (6, 0.2) -- (6, -0.2) node[below] {6};\n\\draw[-] (7, 0.2) -- (7, -0.2) node[below] {7};\n\\draw[-] (8, 0.2) -- (8, -0.2) node[below] {8};\n\\draw[-] (9, 0.2) -- (9, -0.2) node[below] {9};\n\\draw[-] (10, 0.2) -- (10, -0.2) node[below] {10};\nVoici le résultat final avec l’axe et les étiquettes :\n\n\n\n\n\n\n\n\n\nOn peut ensuite ajouter le rectangle bleu au-dessus de l’axe qui contient le text “Il était une fois” :\n\\node[\n    rectangle,\n    draw,\n    fill=blue!20,\n    rounded corners,\n    minimum height=0.8cm,\n    text width=3cm,\n    align=center\n] (fois) at (0.5, 2.5) {Il était une fois};\n\nLa commande \\node[...] (fois) at (0.5, 2.5) {Il était une fois}; crée un nœud nommé fois à la position (0.5, 2.5) avec le texte “Il était une fois”.\nL’option rectangle indique que le nœud doit être dessiné sous forme de rectangle.\nL’option draw indique que le contour du rectangle doit être dessiné.\nL’option fill=blue!20 remplit le rectangle avec une couleur bleue claire.\nL’option rounded corners arrondit les coins du rectangle.\nL’option minimum height=0.8cm définit la hauteur minimale du rectangle.\nL’option text width=3cm définit la largeur du texte à l’intérieur du rectangle.\nL’option align=center centre le texte à l’intérieur du rectangle.\n\nLe résultat doit ressembler à ceci :\n\n\n\n\n\n\n\n\n\nOn peut ajouter les autres rectangles de la même manière :\n\\node[\n    rectangle,\n    draw,\n    fill=blue!20,\n    rounded corners,\n    minimum height=0.8cm,\n    text width=3cm,\n    align=center\n] (reine) at (2.25, -2) {une reine};\n\n\\node[\n    rectangle,\n    draw,\n    fill=blue!20,\n    rounded corners,\n    minimum height=0.8cm,\n    text width=3cm,\n    align=center\n] (roi) at (5.5, 2.5) {un roi};\n\n\\node[\n    rectangle,\n    draw,\n    fill=red!20,\n    rounded corners,\n    minimum height=0.8cm,\n    text width=3cm,\n    align=center\n] (fin) at (8.25, -2) {happy end};\nUne fois ajoutés, le dessin ressemble à ceci :\n\n\n\n\n\n\n\n\n\nEnfin, on peut ajouter les flèches entre qui relient les rectangles avec l’axe :\n\\draw[-&gt;, thick] (fois.south) -- (1, 0.2);\n\\draw[-&gt;, thick] (roi.south) -- (6, 0.2);\n\\draw[-&gt;, thick] (reine.north) -- (3, -0.2);\n\\draw[-&gt;, thick] (fin.north) -- (9, -0.2);\n\nLa commande \\draw[-&gt;, thick] (fois.south) -- (1, 0.2); dessine une flèche épaisse allant du bas du nœud fois (indiqué par fois.south) au point (1, 0.2) sur l’axe, c’est-à-dire juste au-dessus de la graduation 1.\nDe même, les autres commandes dessinent des flèches reliant les autres nœuds aux points correspondants sur l’axe.\n\nLe résultat final est le suivant :\n\n\n\n\n\n\n\n\n\nVoici le code complet pour obtenir l’image souhaitée :\n\\documentclass{standalone}\n\\usepackage{tikz}\n\n\\begin{document}\n\\begin{tikzpicture}\n    \\draw[-&gt;, thick] (-0.5, 0) -- (10.5, 0);\n    \\draw[-] (0, 0.2) -- (0, -0.2) node[below] {0};\n    \\draw[-] (1, 0.2) -- (1, -0.2) node[below] {1};\n    \\draw[-] (2, 0.2) -- (2, -0.2) node[below] {2};\n    \\draw[-] (3, 0.2) -- (3, -0.2) node[below] {3};\n    \\draw[-] (4, 0.2) -- (4, -0.2) node[below] {4};\n    \\draw[-] (5, 0.2) -- (5, -0.2) node[below] {5};\n    \\draw[-] (6, 0.2) -- (6, -0.2) node[below] {6};\n    \\draw[-] (7, 0.2) -- (7, -0.2) node[below] {7};\n    \\draw[-] (8, 0.2) -- (8, -0.2) node[below] {8};\n    \\draw[-] (9, 0.2) -- (9, -0.2) node[below] {9};\n    \\draw[-] (10, 0.2) -- (10, -0.2) node[below] {10};\n\n\n    \\node[\n        rectangle,\n        draw,\n        fill=blue!20,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    ] (fois) at (0.5, 2.5) {Il était une fois};\n\n    \\node[\n        rectangle,\n        draw,\n        fill=blue!20,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    ] (reine) at (2.25, -2) {une reine};\n\n    \\node[\n        rectangle,\n        draw,\n        fill=blue!20,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    ] (roi) at (5.5, 2.5) {un roi};\n\n    \\node[\n        rectangle,\n        draw,\n        fill=red!20,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    ] (fin) at (8.25, -2) {happy end};\n\n    \\draw[-&gt;, thick] (fois.south) -- (1, 0.2);\n    \\draw[-&gt;, thick] (roi.south) -- (6, 0.2);\n    \\draw[-&gt;, thick] (reine.north) -- (3, -0.2);\n    \\draw[-&gt;, thick] (fin.north) -- (9, -0.2);\n\n\\end{tikzpicture}\n\\end{document}\n\n\n2 Version avancée\nLe code précédent fonctionne bien, mais il peut être amélioré en utilisant des boucles pour dessiner les étiquettes de l’axe et en définissant des styles pour les nœuds afin de rendre le code plus lisible et plus facile à modifier.\n\nUtilisation d’une boucle pour les étiquettes de l’axe :\n\n\\foreach \\x in {0,1,...,10} {\n    \\draw[-] (\\x, 0.2) -- (\\x, -0.2) node[below] {\\x};\n}\n\nDéfinition de styles pour les nœuds. En effet, pour éviter de répéter les mêmes options pour chaque nœud, on peut définir des styles personnalisés. La commande \\tikzset{} permet de définir des styles réutilisables. Ci-dessous, nous définissons deux styles : genericbox pour les propriétés communes des boîtes, bluebox pour les boîtes bleues et redbox pour la boîte rouge.\n\n\\tikzset{\n    genericbox/.style={\n        rectangle,\n        draw,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    },\n    bluebox/.style={\n        genericbox,\n        fill=blue!20\n    },\n    redbox/.style={\n        genericbox,\n        fill=red!20\n    }\n}\n\nAmélioration du positionnement des flèches. On peut observer que les flèches qui relient les boîtes à l’axe ne sont pas parfaitement alignées avec les graduations de l’axe. Pour améliorer cela, on peut définir des nœuds invisibles sur l’axe aux positions correspondantes et utiliser ces nœuds comme points de connexion pour les flèches. Voici comment définir ces nœuds invisibles :\n\n\\node[inner sep=0.2cm] (foisinstant) at (1, 0) {};\n\\node[inner sep=0.6cm] (reineinstant) at (3, 0) {};\n\\node[inner sep=0.2cm] (roinstant) at (6, 0) {};\n\\node[inner sep=0.6cm] (fininstant) at (9, 0) {};\nEt voici comment modifier les commandes de dessin des flèches pour utiliser ces nœuds invisibles :\n\\draw[-&gt;, thick] (fois.south) -- (foisinstant.north);\n\\draw[-&gt;, thick] (roi.south) -- (roinstant.north);\n\\draw[-&gt;, thick] (reine.north) -- (reineinstant.south);\n\\draw[-&gt;, thick] (fin.north) -- (fininstant.south);\nVoici le code complet amélioré :\n\\documentclass{standalone}\n\\usepackage{tikz}\n\n\\tikzset{\n    box/.style={\n        rectangle,\n        draw,\n        fill=gray!20,\n        rounded corners,\n        minimum height=0.8cm,\n        text width=3cm,\n        align=center\n    },\n    bluebox/.style={\n        box,\n        fill=blue!20\n    },\n    redbox/.style={\n        box,\n        fill=red!20\n    }\n}\n\n\\begin{document}\n\\begin{tikzpicture}\n    \\draw[-&gt;, thick] (-0.5, 0) -- (10.5, 0);\n    \\foreach \\x in {0,1,...,10} {\n        \\draw[-] (\\x, 0.2) -- (\\x, -0.2) node[below] {\\x};\n    }\n\n    \\node[bluebox] (fois) at (0.5, 2.5) {Il était une fois};\n    \\node[bluebox] (reine) at (2.25, -2) {une reine};\n    \\node[bluebox] (roi) at (5.5, 2.5) {un roi};\n    \\node[redbox] (fin) at (8.25, -2) {happy end};\n\n    \\node[inner sep=0.2cm] (foisinstant) at (1, 0) {};\n    \\node[inner sep=0.6cm] (reineinstant) at (3, 0) {};\n    \\node[inner sep=0.2cm] (roinstant) at (6, 0) {};\n    \\node[inner sep=0.6cm] (fininstant) at (9, 0) {};\n\n    \\draw[-&gt;, thick] (fois.south) -- (foisinstant.north);\n    \\draw[-&gt;, thick] (roi.south) -- (roinstant.north);\n    \\draw[-&gt;, thick] (reine.north) -- (reineinstant.south);\n    \\draw[-&gt;, thick] (fin.north) -- (fininstant.south);\n\n\\end{tikzpicture}\n\\end{document}\nLe résultat final est:"
  },
  {
    "objectID": "02-BasicExample/quarto/main.html",
    "href": "02-BasicExample/quarto/main.html",
    "title": "Exemple 2",
    "section": "",
    "text": "Dans cet exemple, nous allons dessiner un graphique simple en utilisant TikZ, mais cette fois-ci en commençant par le résultat généré par un agent IA comme ChatGPT. L’image ci-dessous représente l’objectif final que nous souhaitons atteindre.\n\n\n\n\n1 ChatGPT\nJ’ai demandé à ChatGPT de générer le code TikZ pour dessiner cette image en utilisant le prompt suivant :\n“Generate the complete, standalone LaTeX code using the TikZ package that exactly reproduces the attached image. Ensure the code is clean, efficient, and compiles without errors.”\nVoici le code TikZ généré par ChatGPT :\n\\documentclass[border=10pt]{standalone}\n\\usepackage{tikz}\n\\usepackage{amsmath}\n\\usetikzlibrary{arrows.meta,decorations.pathmorphing,decorations.pathreplacing}\n\n% Slightly \"sketchy\" style: small random perturbations to mimic hand-drawn look\n\\tikzset{\n  hand/.style={line width=1.2pt, rounded corners=1pt, decorate, decoration={random steps,segment length=1pt,amplitude=0.2pt}},\n  node circle/.style={circle, draw=black!80, very thick, inner sep=1.6pt, minimum size=8pt},\n  thinline/.style={line width=1.0pt},\n  input arrow/.style={-Latex, line width=3pt, draw=red!75!black, shorten &gt;=1pt},\n  output arrow/.style={-Latex, line width=3pt, draw=blue!55!black, shorten &gt;=1pt},\n  normal arrow/.style={-Latex, line width=1.2pt, draw=black!80, shorten &gt;=1pt},\n  faint/.style={opacity=0.6}\n}\n\n\\begin{document}\n\\begin{tikzpicture}[scale=1, every node/.style={font=\\small}]\n\n  % Coordinates chosen to reproduce relative positions\n  \\coordinate (A) at (-4.2,1.4);\n  \\coordinate (B) at (0,1.4);\n  \\coordinate (C) at (3.8,1.4);\n  \\coordinate (D) at (5.6,0.2);   % rightmost exit node\n  \\coordinate (E) at (-1.6,-0.8);\n  \\coordinate (S) at (1.2,-0.6);  % central bottom node\n\n  % Draw horizontal main line top A-B-C\n  \\draw[hand] ($(A)+(0.25,0)$) -- ($(B)-(0.25,0)$) -- ($(C)-(0.25,0)$);\n\n  % Draw horizontal bottom line E -- S\n  \\draw[hand] ($(E)+(0.25,0)$) -- ($(S)-(0.35,0)$);\n\n  % Horizontal from S toward D (slanted a bit)\n  \\draw[hand] ($(S)+(0.4,0.05)$) -- ($(D)-(0.6,0.35)$);\n\n  % Diagonal connectors to form two triangles (B-S and C-S), and E to B\n  \\draw[hand] ($(B)-(0.05,0.12)$) -- ($(S)+( -0.15,0.15)$); % B -&gt; S\n  \\draw[hand] ($(C)-(0.05,0.12)$) -- ($(S)+(0.10,0.12)$);  % C -&gt; S\n  \\draw[hand] ($(E)+(0.14,0.1)$) -- ($(B)-(0.08,0.16)$);    % E -&gt; B\n\n  % Circle nodes\n  \\node[node circle] (nA) at (A) {};\n  \\node[node circle] (nB) at (B) {};\n  \\node[node circle] (nC) at (C) {};\n  \\node[node circle] (nD) at (D) {};\n  \\node[node circle] (nE) at (E) {};\n  \\node[node circle] (nS) at (S) {};\n\n  % Small arrowheads on some connecting lines to indicate direction (like in the photo)\n  \\draw[normal arrow] ($(B)+(-0.08,-0.05)$) -- ($(B)+(0.02,-0.05)$); % small arrow near B pointing rightwards along top\n  \\draw[normal arrow] ($(S)+(-0.06,0.10)$) -- ($(S)+(0.02,0.05)$);  % arrow pointing into S (from above-right)\n  \\draw[normal arrow] ($(B)+(-0.02,-0.22)$) -- ($(B)+(-0.02,-0.12)$); % small arrow on B indicating incoming diagonal\n  \\draw[normal arrow] ($(C)+(-0.02,-0.22)$) -- ($(C)+(-0.02,-0.12)$); % small arrow on C indicating incoming diagonal\n\n  % Thick colored \"input\" red brush-stroke arrows (angled) into A, E and S (entrées)\n  \\draw[input arrow] ($(A)+(-0.9,0.6)$) -- ($(A)+(-0.15,0.02)$);\n  \\draw[input arrow] ($(E)+(-0.7,-0.4)$) -- ($(E)+(-0.12,0.06)$);\n  \\draw[input arrow] ($(S)+(-0.1,-0.85)$) -- ($(S)+(-0.02,0.06)$);\n\n  % Blue \"output\" arrows leaving B, C, D and S (sorties)\n  \\draw[output arrow] ($(nB)+(0.18,0.18)$) -- ($(nB)+(0.9,0.9)$); % small slanted up-right\n  \\draw[output arrow] ($(nC)+(0.28,0.18)$) -- ($(nC)+(1.0,0.9)$);\n  \\draw[output arrow] ($(nD)+(0.18,0.22)$) -- ($(nD)+(1.0,1.0)$);\n  \\draw[output arrow] ($(nS)+(0.38,0.20)$) -- ($(nS)+(1.0,0.9)$);\n\n  % Node labels (A,B,C,E,S etc) placed like handwriting next to circles\n  \\node[above left=2pt of nA] {\\small A};\n  \\node[above=2pt of nB] {\\small B};\n  \\node[above=2pt of nC] {\\small C};\n  \\node[above right=1pt of nD] {\\small D};\n  \\node[above left=2pt of nE] {\\small E};\n  \\node[right=2pt of nS] {\\small F};\n\n  % French group labels similar to the photo\n  \\node[font=\\sffamily\\large\\itshape, red!60!black] at (-3.6,-1.8) {entrées};\n  \\node[font=\\sffamily\\large\\itshape, blue!55!black] at (4.6,1.8) {sorties};\n\n  % small decorative little arcs near some nodes to mimic the hand-drawn curls\n  \\draw[faint, hand] ($(nB)+(-0.26,-0.04)$) -- ($(nB)+(-0.06,0.08)$);\n  \\draw[faint, hand] ($(nC)+(-0.25,-0.06)$) -- ($(nC)+(-0.06,0.07)$);\n  \\draw[faint, hand] ($(nS)+(-0.12,0.02)$) -- ($(nS)+(0.04,0.14)$);\n\n\\end{tikzpicture}\n\\end{document}\nMalheureusement, le code généré par l’agent IA contenait plusieurs erreurs et ne compilait pas correctement. On peut essayer de le fixer en ajoutant manuellement les bibliothèques manquantes et en corrigeant quelques détails mineurs.\n\\usetikzlibrary{calc}\n\\usetikzlibrary{positioning}\n\n...\n\n% Draw horizontal main line top A-B\n\\draw[hand] ($(A)+(0.25,0)$) -- ($(B)-(0.25,0)$);\n\n% Draw horizontal main line B-C\n\\draw[hand] ($(B)+(0.25,0)$) -- ($(C)-(0.25,0)$);\n\n...\nEt maintenant, le code compile correctement mais le résultat final n’est toujours pas parfait. Certaines proportions et positions des éléments ne correspondent pas exactement à l’image de référence.\n\n\n\n\n\n2 Version simple\nOn peut voir que le code généré par l’agent IA est assez complexe et difficile à ajuster. Parfois, il est plus simple de repartir de zéro en utilisant une approche plus basique.\n\nDessiner les nœuds principaux.\n\n\\node [circle, draw] (A) at (0, 0) {A};\n\\node [circle, draw] (B) at (2, 0) {B};\n\\node [circle, draw] (C) at (4, 0) {C};\n\\node [circle, draw] (D) at (6, -1) {D};\n\\node [circle, draw] (E) at (1, -2) {E};\n\\node [circle, draw] (F) at (3, -2) {F};\n\nConnecter les nœuds avec des lignes simples.\n\n\\draw[-&gt;] (A) -- (B);\n\\draw[-&gt;] (B) -- (C);\n\\draw[-&gt;] (C) -- (D);\n\\draw[-&gt;] (E) -- (F);\n\\draw[-&gt;] (F) -- (D);\n\\draw[-&gt;] (E) -- (B);\n\\draw[-&gt;] (B) -- (F);\n\\draw[-&gt;] (F) -- (C);\n\nAjouter les flèches d’entrée et de sortie.\n\n\\draw[thick, &lt;-, red] (A) -- ++ (225:1);\n\\draw[thick, &lt;-, red] (E) -- ++ (225:1) node[left] {entrées};\n\\draw[thick, &lt;-, red] (F) -- ++ (225:1);\n\n\\draw[thick, -&gt;, blue] (B) -- ++ (45:1);\n\\draw[thick, -&gt;, blue] (C) -- ++ (45:1) node[right] {sorties};\n\\draw[thick, -&gt;, blue] (D) -- ++ (45:1);\nEn combinant ces étapes, nous obtenons un code TikZ plus simple et plus facile à ajuster pour correspondre à l’image de référence.\n\\documentclass{standalone}\n\\usepackage{tikz}\n\n\\begin{document}\n\\begin{tikzpicture}\n\n\\node [circle, draw] (A) at (0, 0) {A};\n\\node [circle, draw] (B) at (2, 0) {B};\n\\node [circle, draw] (C) at (4, 0) {C};\n\\node [circle, draw] (D) at (6, -1) {D};\n\\node [circle, draw] (E) at (1, -2) {E};\n\\node [circle, draw] (F) at (3, -2) {F};\n\n\\draw[-&gt;] (A) -- (B);\n\\draw[-&gt;] (B) -- (C);\n\\draw[-&gt;] (C) -- (D);\n\\draw[-&gt;] (E) -- (F);\n\\draw[-&gt;] (F) -- (D);\n\\draw[-&gt;] (E) -- (B);\n\\draw[-&gt;] (B) -- (F);\n\\draw[-&gt;] (F) -- (C);\n\n\\draw[thick, &lt;-, red] (A) -- ++ (225:1);\n\\draw[thick, &lt;-, red] (E) -- ++ (225:1) node[left] {entrées};\n\\draw[thick, &lt;-, red] (F) -- ++ (225:1);\n\n\\draw[thick, -&gt;, blue] (B) -- ++ (45:1);\n\\draw[thick, -&gt;, blue] (C) -- ++ (45:1) node[right] {sorties};\n\\draw[thick, -&gt;, blue] (D) -- ++ (45:1);\n\n\\end{tikzpicture}\n\\end{document}\n\n\n3 Version améliorée\nLe code ci-dessus produit un graphique fonctionnel, mais il peut être amélioré sur plusieurs aspects:\n\nMettre les étiquettes des nœuds à côté des cercles au lieu de l’intérieur.\nFactoriser les styles pour les nœuds et les flèches.\nFactoriser les positions des nœuds pour un ajustement plus facile.\n\nVoici une version améliorée du code :\n\\documentclass{standalone}\n\\usepackage{tikz}\n\n\\begin{document}\n\n\\tikzset{\n    node circle/.style={\n        circle,\n        draw=black!80,\n        very thick,\n        inner sep=1pt,\n        minimum size=4pt\n    },\n    edge arrow/.style={\n        -&gt;,\n        line width=1.2pt,\n        draw=black!80,\n        shorten &gt;=1pt\n    },\n    input arrow/.style={\n        &lt;-,\n        line width=1.5pt,\n        draw=red!75!black,\n        shorten &lt;=1pt\n    },\n    output arrow/.style={\n        -&gt;,\n        line width=1.5pt,\n        draw=blue!55!black,\n        shorten &gt;=1pt\n    }\n}\n\n\\begin{tikzpicture}\n\n\\def\\unitheight{1.25}\n\\def\\unitwidth{1.5}\n\n\\def\\inputangle{225}\n\\def\\inputradius{1}\n\n\\def\\outputangle{45}\n\\def\\outputradius{1}\n\n\\node [node circle, label=145:A] (A) at (0, 0) {};\n\\node [node circle, label=100:B] (B) at (2 * \\unitwidth, 0) {};\n\\node [node circle, label=100:C] (C) at (4 * \\unitwidth, 0) {};\n\\node [node circle, label=0:D] (D) at (6 * \\unitwidth, -1 * \\unitheight) {};\n\\node [node circle, label=170:E] (E) at (1 * \\unitwidth, -2 * \\unitheight) {};\n\\node [node circle, label=280:F] (F) at (3 * \\unitwidth, -2 * \\unitheight) {};\n\n\\draw [edge arrow] (A) -- (B);\n\\draw [edge arrow] (B) -- (C);\n\\draw [edge arrow] (C) -- (D);\n\\draw [edge arrow] (E) -- (F);\n\\draw [edge arrow] (F) -- (D);\n\\draw [edge arrow] (E) -- (B);\n\\draw [edge arrow] (B) -- (F);\n\\draw [edge arrow] (F) -- (C);\n\n\\draw[input arrow] (A) -- ++ (\\inputangle:\\inputradius);\n\\draw[input arrow] (E) -- ++ (\\inputangle:\\inputradius) node[left] {entrées};\n\\draw[input arrow] (F) -- ++ (\\inputangle:\\inputradius);\n\n\\draw[output arrow] (B) -- ++ (\\outputangle:\\outputradius);\n\\draw[output arrow] (C) -- ++ (\\outputangle:\\outputradius) node[right] {sorties};\n\\draw[output arrow] (D) -- ++ (\\outputangle:\\outputradius);\n\n\\end{tikzpicture}\n\\end{document}\n\n\n4 Version avancée\nOn peut encore améliorer le code en utilisant des boucles pour dessiner les nœuds et les flèches, ce qui rend le code plus compact et plus facile à modifier.\n\\documentclass{standalone}\n\\usepackage{tikz}\n\n\\begin{document}\n\n\\tikzset{\n    node circle/.style={\n        circle,\n        draw=black!80,\n        very thick,\n        inner sep=1pt,\n        minimum size=4pt\n    },\n    edge arrow/.style={\n        -&gt;,\n        line width=1.2pt,\n        draw=black!80,\n        shorten &gt;=1pt\n    },\n    input arrow/.style={\n        &lt;-,\n        line width=1.5pt,\n        draw=red!75!black,\n        shorten &lt;=1pt\n    },\n    output arrow/.style={\n        -&gt;,\n        line width=1.5pt,\n        draw=blue!55!black,\n        shorten &gt;=1pt\n    }\n}\n\n\\begin{tikzpicture}\n\n\\def\\unitheight{1.25}\n\\def\\unitwidth{1.5}\n\n\\def\\inputangle{225}\n\\def\\inputradius{1}\n\n\\def\\outputangle{45}\n\\def\\outputradius{1}\n\n\\foreach \\nodelabel/\\labelangle/\\nodex/\\nodey in {\n    A/145/0/0,\n    B/100/2/0,\n    C/100/4/0,\n    D/0/6/-1,\n    E/170/1/-2,\n    F/280/3/-2%\n} {\n    \\node [\n        node circle,\n        label=\\labelangle:\\nodelabel\n    ] (\\nodelabel) at (\\nodex * \\unitwidth, \\nodey * \\unitheight) {};\n}\n\n\\foreach \\startnode/\\endnode in {\n    A/B,\n    B/C,\n    C/D,\n    E/F,\n    F/D,\n    E/B,\n    B/F,\n    F/C%\n} {\n    \\draw [edge arrow] (\\startnode) -- (\\endnode);\n}\n\n\\foreach \\nodelabel in {A, E, F} {\n    \\draw [input arrow] (\\nodelabel) -- ++ (\\inputangle:\\inputradius);\n}\n\n\\foreach \\nodelabel in {B, C, D} {\n    \\draw [output arrow] (\\nodelabel) -- ++ (\\outputangle:\\outputradius);\n}\n\n\\path (E) -- ++ (\\inputangle:\\inputradius) node[left, red] {entrées};\n\\path (C) -- ++ (\\outputangle:\\outputradius) node[right, blue] {sorties};\n\n\\end{tikzpicture}\n\\end{document}"
  },
  {
    "objectID": "04-VRP/quarto/main.html",
    "href": "04-VRP/quarto/main.html",
    "title": "Graphe du VRP",
    "section": "",
    "text": "Dans cet exemple, nous allons créer un graphe représentant un problème de routage de véhicules (VRP) en utilisant TikZ. Le graphe illustrera les clients, le dépôt, et les routes empruntées par les véhicules."
  },
  {
    "objectID": "03-ProjectileMotion/quarto/main.html",
    "href": "03-ProjectileMotion/quarto/main.html",
    "title": "Mouvement d’un projectile",
    "section": "",
    "text": "On souhaite utiliser TikZ pour tracer la trajectoire d’un projectile lancé avec une vitesse initiale et un angle donnés. Nous allons également représenter la vitesse du projectile à différents instants de son vol comme illustré ci-dessous.\n\n\n\n\n1 Préambule\nUn projectile est lancé avec une vitesse initiale \\(v_{0}\\) sous un angle \\(\\theta\\) par rapport à l’horizontale. La trajectoire du projectile est influencée par la gravité, qui agit vers le bas avec une accélération constante \\(g\\). Les équations du mouvement du projectile sont données par :\n\\[\nx(t) = v_{0} \\cos(\\theta) t\n\\]\n\\[\ny(t) = -\\frac{1}{2} g t^{2} + v_{0} \\sin(\\theta) t\n\\]\noù \\(x(t)\\) et \\(y(t)\\) sont les positions horizontale et verticale du projectile à l’instant \\(t\\).\nLes équations de la vitesse du projectile sont données par :\n\\[\nv_{x}(t) = v_{0} \\cos(\\theta)\n\\]\n\\[\nv_{y}(t) = -g t + v_{0} \\sin(\\theta)\n\\]\nLa durée totale de vol \\(T\\) du projectile peut être calculée en trouvant le temps lorsque le projectile revient au sol (\\(y(T) = 0\\)) :\n\\[\nT = \\frac{2 v_{0} \\sin(\\theta)}{g}\n\\]\n\n\n2 Étapes de la construction\n\nDéfinir les paramètres initiaux : Choisir une vitesse initiale \\(v_{0}\\), un angle de lancement \\(\\theta\\), et la valeur de l’accélération due à la gravité \\(g\\).\nCalculer la durée totale de vol : Utiliser la formule pour \\(T\\) afin de déterminer combien de temps le projectile restera en l’air.\nTracer les axes : Dessiner les axes horizontaux et verticaux pour représenter le plan de mouvement du projectile.\nTracer le projectile : Utiliser les équations de position pour tracer le projectile à différents instants de temps entre \\(t=0\\) et \\(t=T\\).\nAjouter les vecteurs de vitesse : À plusieurs instants de temps, calculer les composantes de la vitesse \\(v_{x}(t)\\) et \\(v_{y}(t)\\), puis dessiner les vecteurs de vitesse à ces points sur la trajectoire.\nAjouter la trajectoire complète : Tracer la trajectoire complète du projectile en utilisant une courbe lisse qui relie tous les points calculés.\n\n\n\n3 Code TikZ\nVoici un exemple de code TikZ pour réaliser ce tracé :\n\\documentclass{standalone}\n\\usepackage{tikz}\n\\usetikzlibrary{calc}\n\n\\begin{document}\n\n\\tikzset{\n    axis/.style={-stealth},\n}\n\n\\begin{tikzpicture}[scale=4]\n    \\def\\InitialAngle{40}\n    \\def\\InitialVelocity{6}\n    \\def\\Gravity{9.8}\n    \\def\\BallRadius{0.1}\n    \\def\\VelocityScale{0.1}\n    \\def\\AngleScale{1.6}\n    \\def\\AxisXMargin{0.3}\n    \\def\\AxisXScale{1.2}\n    \\def\\AxisYMargin{0.3}\n    \\def\\AxisYScale{1.2}\n\n    \\pgfmathsetmacro{\\MaximumTime}{%\n        2*\\InitialVelocity*sin(\\InitialAngle)/\\Gravity%\n    }\n    \\pgfmathdeclarefunction{BallX}{1}{%\n        \\pgfmathparse{%\n            \\InitialVelocity*(#1*\\MaximumTime)*cos(\\InitialAngle)%    \n        }\n    }\n    \\pgfmathdeclarefunction{BallY}{1}{%\n        \\pgfmathparse{%\n            -0.5*\\Gravity*(#1*\\MaximumTime)^2%\n            +\\InitialVelocity*(#1*\\MaximumTime)*sin(\\InitialAngle)%\n        }\n    }\n    \\pgfmathdeclarefunction{BallVx}{1}{%\n        \\pgfmathparse{%\n            \\InitialVelocity*cos(\\InitialAngle)%\n        }\n    }\n    \\pgfmathdeclarefunction{BallVy}{1}{%\n        \\pgfmathparse{%\n            -\\Gravity*(#1*\\MaximumTime)%\n            +\\InitialVelocity*sin(\\InitialAngle)%\n        }\n    }\n    \\newcommand\\BallXFormula{%\n        x = v_{0}t\\cos\\theta\n    }\n    \\newcommand\\BallYFormula{%\n        y = -\\frac{1}{2}gt^{2} + v_{0}t\\sin\\theta\n    }\n\n    \\pgfmathsetmacro{\\MaximumX}{BallX(1.0)}\n    \\pgfmathsetmacro{\\MaximumY}{BallY(0.5)}\n\n    \\newcommand{\\DrawBall}[2][black]{\n        \\coordinate (P) at ({BallX(#2)},{BallY(#2)});\n        \\coordinate (V) at ({BallVx(#2)},{BallVy(#2)});\n        \\filldraw[ball color=#1!50!]\n            (P) circle (\\BallRadius);\n        \\draw[-stealth, thick, #1]\n            (P) --++($\\VelocityScale*(V)$)\n            node[above, sloped] {$\\vec{v}$};\n    }\n    \n    \\draw[axis]\n        (-\\AxisXMargin,0) -- ($\\AxisXScale*(\\MaximumX,0)$)\n        node[right] {$x$};\n\n    \\draw[axis]\n        (0,-\\AxisYMargin) -- ($\\AxisYScale*(0,\\MaximumY)$)\n        node[above] {$y$};\n\n    \\filldraw[opacity=0.2, fill=blue!50]\n        (\\BallRadius*\\AngleScale,0) arc (0:\\InitialAngle:\\BallRadius*\\AngleScale)\n        node[opacity=1, midway, above right] {$\\theta$}\n        -- (0,0) -- cycle;\n\n    \\foreach \\t in {0,0.8,1} {\n        \\DrawBall{\\t}\n    }\n    \n    \\pgfmathsetmacro{\\TimeToLabel}{0.225}\n    \\DrawBall[blue]{\\TimeToLabel}\n    \\coordinate (Pt) at ({BallX(\\TimeToLabel)},{BallY(\\TimeToLabel)}); \n    \\draw[densely dotted]\n        (Pt) -- (Pt |- 0, 0)\n        node[below] {$\\BallXFormula$}\n        (Pt) -- (Pt -| 0, 0)\n        node[left] {$\\displaystyle \\BallYFormula$}\n        ;\n    \\DrawBall[red]{0.5}\n\n    \\draw[\n        samples=256,\n        densely dotted,\n        domain=0:1,\n        variable=\\t\n    ] plot ({BallX(\\t)}, {BallY(\\t)});\n\n\\end{tikzpicture}\n\\end{document}"
  }
]